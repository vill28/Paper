From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Jason Penilla <11360596+jpenilla@users.noreply.github.com>
Date: Mon, 16 Aug 2021 01:31:54 -0500
Subject: [PATCH] Add '/paper mobcaps' command to view how full the mobcaps are

Also has a hover text on each mob category listing what entity types are in said category

TODO: Account for per-player spawning

diff --git a/src/main/java/com/destroystokyo/paper/PaperCommand.java b/src/main/java/com/destroystokyo/paper/PaperCommand.java
index f170dff5140d9beaaee3d987ae820b5971a8aa49..1f25d1925da71180b51feb09566f456af3e9ab5d 100644
--- a/src/main/java/com/destroystokyo/paper/PaperCommand.java
+++ b/src/main/java/com/destroystokyo/paper/PaperCommand.java
@@ -10,6 +10,10 @@ import com.google.common.collect.Maps;
 import com.google.gson.JsonObject;
 import com.google.gson.internal.Streams;
 import com.google.gson.stream.JsonWriter;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.TextComponent;
+import net.kyori.adventure.text.format.NamedTextColor;
+import net.minecraft.core.Registry;
 import net.minecraft.resources.ResourceLocation;
 import net.minecraft.server.MCUtil;
 import net.minecraft.server.MinecraftServer;
@@ -19,10 +23,12 @@ import net.minecraft.server.level.ServerLevel;
 import net.minecraft.server.level.ServerPlayer;
 import net.minecraft.server.level.ThreadedLevelLightEngine;
 import net.minecraft.world.entity.EntityType;
+import net.minecraft.world.entity.MobCategory;
 import net.minecraft.world.level.ChunkPos;
 import net.minecraft.network.protocol.game.ClientboundLightUpdatePacket;
 import net.minecraft.resources.ResourceLocation;
 import net.minecraft.server.MCUtil;
+import net.minecraft.world.level.NaturalSpawner;
 import org.apache.commons.lang3.tuple.MutablePair;
 import org.apache.commons.lang3.tuple.Pair;
 import org.bukkit.Bukkit;
@@ -49,8 +55,10 @@ import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.Collections;
+import java.util.Comparator;
 import java.util.Deque;
 import java.util.Iterator;
+import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Locale;
 import java.util.Map;
@@ -59,7 +67,7 @@ import java.util.stream.Collectors;
 
 public class PaperCommand extends Command {
     private static final String BASE_PERM = "bukkit.command.paper.";
-    private static final ImmutableSet<String> SUBCOMMANDS = ImmutableSet.<String>builder().add("heap", "entity", "reload", "version", "debug", "chunkinfo", "fixlight", "syncloadinfo", "dumpitem").build();
+    private static final ImmutableSet<String> SUBCOMMANDS = ImmutableSet.<String>builder().add("heap", "entity", "reload", "version", "debug", "chunkinfo", "fixlight", "syncloadinfo", "dumpitem", "mobcaps").build();
 
     public PaperCommand(String name) {
         super(name);
@@ -92,6 +100,8 @@ public class PaperCommand extends Command {
                     return getListMatchingLast(sender, args, "help", "chunks");
                 }
                 break;
+            case "mobcaps":
+                return getListMatchingLast(sender, args, this.suggestMobcaps(sender, args));
             case "chunkinfo":
                 List<String> worldNames = new ArrayList<>();
                 worldNames.add("*");
@@ -188,6 +198,9 @@ public class PaperCommand extends Command {
             case "syncloadinfo":
                 this.doSyncLoadInfo(sender, args);
                 break;
+            case "mobcaps":
+                this.printMobcaps(sender, args);
+                break;
             case "ver":
                 if (!testPermission(sender, "version")) break; // "ver" needs a special check because it's an alias. All other commands are checked up before the switch statement (because they are present in the SUBCOMMANDS set)
             case "version":
@@ -246,6 +259,115 @@ public class PaperCommand extends Command {
         }
     }
 
+    private static final List<NamedTextColor> COLORS_FOR_MOB_CATEGORIES = NamedTextColor.NAMES.values().stream()
+        .filter(color -> color != NamedTextColor.WHITE && color != NamedTextColor.BLACK && color != NamedTextColor.GRAY && color != NamedTextColor.DARK_GRAY)
+        .sorted(Comparator.comparing(Object::toString))
+        .toList();
+
+    private static final Map<MobCategory, NamedTextColor> MOB_CATEGORY_COLORS = new LinkedHashMap<>() {{
+        final List<MobCategory> categories = Arrays.asList(MobCategory.values());
+        for (int i = 0; i < categories.size(); i++) {
+            int colorIndex = i;
+            while (colorIndex > COLORS_FOR_MOB_CATEGORIES.size() - 1) {
+                colorIndex = colorIndex - COLORS_FOR_MOB_CATEGORIES.size();
+            }
+            this.put(categories.get(i), COLORS_FOR_MOB_CATEGORIES.get(colorIndex));
+        }
+    }};
+
+    private List<String> suggestMobcaps(CommandSender sender, String[] args) {
+        if (args.length == 2) {
+            final List<String> worlds = new ArrayList<>(Bukkit.getWorlds().stream().map(World::getName).toList());
+            worlds.add("*");
+            return worlds;
+        }
+
+        return Collections.emptyList();
+    }
+
+    private void printMobcaps(CommandSender sender, String[] args) {
+        final List<World> worlds;
+        if (args.length == 1) {
+            if (sender instanceof Player player) {
+                worlds = List.of(player.getWorld());
+            } else {
+                sender.sendMessage(Component.text("Must specify a world! ex: '/paper mobcaps world'", NamedTextColor.RED));
+                return;
+            }
+        } else if (args.length == 2) {
+            final String input = args[1];
+            if (input.equals("*")) {
+                worlds = Bukkit.getWorlds();
+            } else {
+                final World world = Bukkit.getWorld(input);
+                if (world == null) {
+                    sender.sendMessage(Component.text("'" + input + "' is not a valid world!", NamedTextColor.RED));
+                    return;
+                } else {
+                    worlds = List.of(world);
+                }
+            }
+        } else {
+            sender.sendMessage(Component.text("Too many arguments!", NamedTextColor.RED));
+            return;
+        }
+
+        for (final World world : worlds) {
+            final NaturalSpawner.SpawnState state = ((CraftWorld) world).getHandle().getChunkSource().getLastSpawnState();
+
+            final TextComponent.Builder builder = Component.text();
+
+            final int chunks;
+            if (state == null) {
+                chunks = 0;
+            } else {
+                chunks = state.getSpawnableChunkCount();
+            }
+            builder.append(
+                Component.text("Mobcaps for world: "),
+                Component.text(world.getName(), NamedTextColor.AQUA),
+                Component.text(" (" + chunks + " spawnable chunks)")
+            );
+
+            MOB_CATEGORY_COLORS.forEach((category, color) -> {
+                final int count;
+                if (state == null) {
+                    count = 0;
+                } else {
+                    count = state.getMobCategoryCounts().getOrDefault(category, 0);
+                }
+
+                final Component categoryHover = TextComponent.ofChildren(
+                    Component.text("Entity types in category "),
+                    Component.text(category.getName(), NamedTextColor.AQUA),
+                    Component.text(':', NamedTextColor.GRAY),
+                    Component.newline(),
+                    Registry.ENTITY_TYPE.entrySet().stream()
+                        .filter(it -> it.getValue().getCategory() == category)
+                        .map(it -> Component.translatable(it.getValue().getDescriptionId()))
+                        .collect(Component.toComponent(Component.text(", ", NamedTextColor.GRAY)))
+                );
+
+                final Component categoryComponent = Component.text()
+                    .content("  " + category.getName())
+                    .color(color)
+                    .hoverEvent(categoryHover)
+                    .build();
+
+                builder.append(
+                    Component.newline(),
+                    categoryComponent,
+                    Component.text(": ", NamedTextColor.GRAY),
+                    Component.text(count),
+                    Component.text("/", NamedTextColor.GRAY),
+                    Component.text(NaturalSpawner.limitForCategory(((CraftWorld) world).getHandle(), category))
+                );
+            });
+
+            sender.sendMessage(builder);
+        }
+    }
+
     private void doChunkInfo(CommandSender sender, String[] args) {
         List<org.bukkit.World> worlds;
         if (args.length < 2 || args[1].equals("*")) {
diff --git a/src/main/java/net/minecraft/world/level/NaturalSpawner.java b/src/main/java/net/minecraft/world/level/NaturalSpawner.java
index 88145f04989c71a686aae1b486087ecdf55e268c..a2bdba4d296ae2583c38fb30040180168e73a4be 100644
--- a/src/main/java/net/minecraft/world/level/NaturalSpawner.java
+++ b/src/main/java/net/minecraft/world/level/NaturalSpawner.java
@@ -144,28 +144,15 @@ public final class NaturalSpawner {
             MobCategory enumcreaturetype = aenumcreaturetype[j];
             // CraftBukkit start - Use per-world spawn limits
             boolean spawnThisTick = true;
-            int limit = enumcreaturetype.getMaxInstancesPerChunk();
+            final int limit = limitForCategory(world, enumcreaturetype); // Paper
             switch (enumcreaturetype) {
-                case MONSTER:
-                    spawnThisTick = spawnMonsterThisTick;
-                    limit = world.getWorld().getMonsterSpawnLimit();
-                    break;
-                case CREATURE:
-                    spawnThisTick = spawnAnimalThisTick;
-                    limit = world.getWorld().getAnimalSpawnLimit();
-                    break;
-                case WATER_CREATURE:
-                    spawnThisTick = spawnWaterThisTick;
-                    limit = world.getWorld().getWaterAnimalSpawnLimit();
-                    break;
-                case AMBIENT:
-                    spawnThisTick = spawnAmbientThisTick;
-                    limit = world.getWorld().getAmbientSpawnLimit();
-                    break;
-                case WATER_AMBIENT:
-                    spawnThisTick = spawnWaterAmbientThisTick;
-                    limit = world.getWorld().getWaterAmbientSpawnLimit();
-                    break;
+                // Paper start - not mindiff so we get conflict on change
+                case MONSTER -> spawnThisTick = spawnMonsterThisTick;
+                case CREATURE -> spawnThisTick = spawnAnimalThisTick;
+                case WATER_CREATURE -> spawnThisTick = spawnWaterThisTick;
+                case AMBIENT -> spawnThisTick = spawnAmbientThisTick;
+                case WATER_AMBIENT -> spawnThisTick = spawnWaterAmbientThisTick;
+                // Paper end
             }
 
             if (!spawnThisTick || limit == 0) {
@@ -204,6 +191,19 @@ public final class NaturalSpawner {
         world.getProfiler().pop();
     }
 
+    // Paper start
+    public static int limitForCategory(final ServerLevel world, final MobCategory enumcreaturetype) {
+        return switch (enumcreaturetype) {
+            case MONSTER -> world.getWorld().getMonsterSpawnLimit();
+            case CREATURE -> world.getWorld().getAnimalSpawnLimit();
+            case WATER_CREATURE -> world.getWorld().getWaterAnimalSpawnLimit();
+            case AMBIENT -> world.getWorld().getAmbientSpawnLimit();
+            case WATER_AMBIENT -> world.getWorld().getWaterAmbientSpawnLimit();
+            default -> enumcreaturetype.getMaxInstancesPerChunk();
+        };
+    }
+    // Paper end
+
     // Paper start - add parameters and int ret type
     public static void spawnCategoryForChunk(MobCategory group, ServerLevel world, LevelChunk chunk, NaturalSpawner.SpawnPredicate checker, NaturalSpawner.AfterSpawnCallback runner) {
         spawnCategoryForChunk(group, world, chunk, checker, runner);
